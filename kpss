#!/bin/sh
#shellcheck disable=SC3043


#Variables
CUT="/usr/bin/cut"
FIND="/usr/bin/find"
GPG="/usr/bin/gpg"
GPG_OPTS="--batch --quiet --yes --compress-algo=none --no-encrypt-to"
GREP="/usr/bin/grep"
HEAD="/usr/bin/head"
KPSS_DIR="${HOME}/src/pass"
KPSS_KEY="5F48FC0A00DA717169ABF80E29A7C5C548EF4B92"
MKDIR="/usr/bin/mkdir"
NOTIFY="/usr/bin/notify-send"
RAND="/dev/urandom"
SED="/usr/bin/sed"
SELECTION="/tmp/kpss.selection"
TEE="/usr/bin/tee"
TOFI="/usr/bin/tofi"
TR="/usr/bin/tr"
WTYPE="/usr/bin/wtype"

#Functions
create_file()
{
  local content=""
  local file=""
  local info=""
  local pass=""
  local user=""

  file="${1}"
  user="${2}"
  pass="${3}"
  info="${4}"
  content="$(PATH="" printf 'user:%s\n%s\ninfo:%s\n' "${user}" "${pass}" "${info}")"
  "${MKDIR}" --parents "${KPSS_DIR}/${file%/*}"
  PATH="" printf '%s\n' "${content}" | eval "${GPG}" "${GPG_OPTS}" --encrypt --recipient "${KPSS_KEY}" --output "${KPSS_DIR}/${file}"
}

generate_file()
{
  local choice=""
  local content=""
  local file=""
  local info=""
  local pass=""
  local user=""

  file="${1}"
  user="$("${TOFI}" --prompt-text "Username: " < /dev/null)"

  pass="$(input_pass)"
  if [ "${pass}" = "kpss.error:password.mismatch" ]
  then
    "${NOTIFY}" --hint "string:x-canonical-private-synchronous:tag-kpss" "Pass" "Passwords does not match"
    return
  fi

  info="$("${TOFI}" --prompt-text "Information: " < /dev/null)"
  create_file "${file}" "${user}" "${pass}" "${info}"
  "${NOTIFY}" --hint "string:x-canonical-private-synchronous:tag-kpss-${file}" "Pass" "Created ${file}"
}

generate_pass()
{
  local alpha=""
  local char=""
  local extra=""
  local len=""
  local num=""
  local pass=""

  len="$("${TOFI}" --prompt-text "Length: " < /dev/null)"
  [ -z "${len}" ] && len="32"
  alpha="$(printf 'Yes\nNo' | "${TOFI}" --require-match true --prompt-text "Alpahbets: " )"
  num="$(printf 'Yes\nNo' | "${TOFI}" --require-match true --prompt-text "Numbers: " )"
  extra="$(printf 'Yes\nNo' | "${TOFI}" --prompt-text "Special: " )"
  [ "${alpha}" = "Yes" ] && char="[:alpha:]"
  [ "${num}" = "Yes" ] && char="${char}[:digit:]"
  [ "${extra}" = "Yes" ] && extra="[:punct:]"
  [ "${extra}" = "No" ] && extra=""
  char="${char}${extra}"
  [ -z "${char}" ] && char="[:alpha:][:digit:][:punct:]"
  pass="$(random_pass "${char}" "${len}")"
  PATH="" printf '%s' "${pass}"
}

input_pass()
{
  local choice=""
  local pass=""
  local pass_re=""

  pass="$("${TOFI}" --prompt-text "Password: " --hide-input true < /dev/null)"
  pass_re="$("${TOFI}" --prompt-text "Password(Retype): " --hide-input true < /dev/null)"
  if [ "${pass}" != "${pass_re}" ]
  then
    printf 'kpss.error:password.mismatch'
    return
  fi

  if [ -z "${pass}" ]
  then
    choice="$(printf 'Yes\nNo' | "${TOFI}" --require-match true --prompt-text "Generate Password: ")"
    if [ "${choice}" = "Yes" ]
    then
      pass="$(generate_pass)"
    fi
  else
    pass="$(PATH="" printf 'pass:%s\nchar:\nlen:\n' "${pass}")"
  fi

  PATH="" printf '%s' "${pass}"
}

output_info()
{
  local content=""
  local file=""
  local info=""

  info="${1}"
  read -r file < "${SELECTION}"
  if [ -f "${KPSS_DIR}/${file}" ]
  then
    content="$(eval "${GPG}" "${GPG_OPTS}" --decrypt "${KPSS_DIR}/${file}" \| "${GREP}" "^${info}:")"
    if [ -n "${content}" ]
    then
      printf '%s' "${content#"${info}:"}" | "${WTYPE}" -
      "${NOTIFY}" --hint "string:x-canonical-private-synchronous:tag-kpss-${file}" "Pass" "Pasted ${info} for ${file}"
    fi
  fi
}

random_pass()
{
  local char=""
  local len=""
  local pass=""

  char="${1}"
  len="${2}"
  pass="$("${HEAD}" --lines 10000 "${RAND}" | "${TR}" -dc "${char}" | "${CUT}" -c 101-"$(( 100 + len ))")"
  pass="$(PATH="" printf 'pass:%s\nchar:%s\nlen:%s\n' "${pass}" "${char}" "${len}")"
  PATH="" printf '%s' "${pass}"
}

select_file()
{
  local file=""

  file="$("${FIND}" "${KPSS_DIR}" ! -path '*.git*' -type f -printf '%P\n' | "${TOFI}" --require-match true --fuzzy-match true | "${TEE}" "${SELECTION}")"
  if [ -n "${file}" ]
  then
    "${NOTIFY}" --hint "string:x-canonical-private-synchronous:tag-kpss-${file}" "Pass" "Selected ${file}"
  fi
}

update_file()
{
  local char=""
  local choice=""
  local content=""
  local file=""
  local info=""
  local len=""
  local pass=""
  local user=""

  file="${1}"
  content="$(eval "${GPG}" "${GPG_OPTS}" --decrypt "${KPSS_DIR}/${file}")"
  user="$(printf '%s\n' "${content}" | "${SED}" --quiet --expression "/^user:/{s|^user:||g;p}")"
  pass="$(printf '%s\n' "${content}" | "${SED}" --quiet --expression "/^pass:/{s|^pass:||g;p}")"
  char="$(printf '%s\n' "${content}" | "${SED}" --quiet --expression "/^char:/{s|^char:||g;p}")"
  len="$(printf '%s\n' "${content}" | "${SED}" --quiet --expression "/^len:/{s|^len:||g;p}")"
  pass="$(PATH="" printf 'pass:%s\nchar:%s\nlen:%s\n' "${pass}" "${char}" "${len}")"
  info="$(printf '%s\n' "${content}" | "${SED}" --quiet --expression "/^info:/{s|^info:||g;p}")"

  choice="$(printf 'User\nPass\nInfo' | "${TOFI}" --require-match true --prompt-text "Update: ")"
  if [ "${choice}" = "User" ]
  then
    user="$("${TOFI}" --prompt-text "Username: " < /dev/null)"
  elif [ "${choice}" = "Pass" ]
  then
    choice="$(printf 'Yes\nNo' | "${TOFI}" --require-match true --prompt-text "Regenerate Password: ")"
    if [ "${choice}" = "Yes" ]
    then
      pass="$(random_pass "${char}" "${len}")"
    else
      pass="$(input_pass)"
    fi
  elif [ "${choice}" = "Info" ]
  then
    info="$("${TOFI}" --prompt-text "Information: " < /dev/null)"
  fi

  create_file "${file}" "${user}" "${pass}" "${info}"
  "${NOTIFY}" --hint "string:x-canonical-private-synchronous:tag-kpss-${file}" "Pass" "Updated ${file}"
}

update_pass()
{
  local file=""

  file="$("${FIND}" "${KPSS_DIR}" ! -path '*.git*' -type f -printf '%P\n' | "${TOFI}" --require-match false --fuzzy-match false)"
  if [ -f "${KPSS_DIR}/${file}" ]
  then
    update_file "${file}"
  else
    if [ -n "${file}" ]
    then
      generate_file "${file}"
    fi
  fi
  printf '%s\n' "${file}" > "${SELECTION}"
}

#Main
export PATH=""
if [ "${1}" = "update" ]
then
  update_pass
elif [ -n "${1}" ]
then
  output_info "${1}"
else
  select_file
fi
